# 动态语言与静态语言
  ## 内联缓存：记录上次命中位置方便下次查找，不要删除热点属性和改变属性顺序
  | 特征        | 实现细节                                          |
    | --------- | --------------------------------------------- |
    | **形状系统**  | **隐藏类（Map）**——相同属性顺序共用一张表，记录偏移量。              |
    | **IC 状态** | **单态（1 条记录）→ 多态（≤4）→ 超态（megamorphic，放弃 IC）**。 |
    | **缓存内容**  | **“Map 地址 + 属性偏移”**，命中时一条指令读取内存。              |
    | **回退**    | 隐藏类变化 → 存根（stub）失效 → 回退到哈希查找，并更新 IC slot。     |
    | **优化提示**  | 不要事后增删属性，不要改属性顺序，否则退化为慢路径。                    |

  ## 字节码和机器码
    1. 字节码保留了类型信息 还能看懂一点点 绑定平台
    2. 机器码 看不懂的十六进制  绑定CPU
  ## 虚拟机（VM）不是语言必需品，而是一种“跨平台 + 动态功能”可选运行时；它把硬件指令抽象成字节码，再边解释边执行或二次编译，让同一份源码到处跑。：
   - 只要编译产物不是“裸机器码”，就需要VM当运行时宿主 “语言要不要虚拟机，看它产什么：产出字节码→必须VM当宿主；产出机器码→直接跑CPU。
   - VM就是‘软件CPU+运行时服务’，让跨平台、GC、反射、JIT成为可能，但也带来启动慢、内存大的代价。”
   需要VM (js,java,c#,python)
   不需要VM（rust,c,c++,go）

1. 动态语言（js）解释器（源码 → 字节码 → VM/JIT） 效率低一点 用隐藏类和内联缓存优化
   - 真正瓶颈在于 运行时类型检查、方法分派、内存模型，而不是“动态”本身。
2. 静态语言（rust） 需要编译器（源码 → 机器码 → 直接运行）   
   